APIs or Standards
â€¢ Asynchronicity
  â–´ Parallel: OpenMP, SIMD, â€¦
  â–´ Wait
â€¢ Audio: WaveOut â†’ Windows Audio Session (WASAPI) â†’ XAudio2 â†’ DirectSound â†’ Audio Stream Input/ Output (ASIO)
  â•°â”€ 3GP `.3gp`, Audible AA `.aa` `.aax`, Advanced Audio Encoding `.aac`, â€¦
â€¢ Font
  â•°â”€ TrueType `.ttf`, â€¦
â€¢ Image: â€¦
  â–´ Matrix
  â”‚ â•°â”€ QR: â€¦
  â•°â”€ APNG `.apng`, AVIF `.avif`, BMP `.bmp`, CR3 `.cr3`, GIF `.gif`, JPEG `.jpeg` `.jpg`, PNG `.png`, SVG `.svg`, WEBP `.webp`, â€¦
â€¢ Mathematics
  â–´ Geometry
  â–´ Physics
  â–´ Random
  â–´ Timing
â€¢ Network: Windows Sockets 2 (winsock2) â†’ Windows HTTP Services (winhttp) â†’ Windows Internet (wininet)
  â•°â”€ TCP, UDP, â€¦
â€¢ Serialization
â€¢ Source
â€¢ System
  â–´ Clipboard : â€¦
  â–´ Console   : â€¦
  â–´ Filesystem: â€¦
    â•°â”€ â€¦
  â–´ Hardware
    â–ª Battery    : â€¦
    â–ª Biometrics : â€¦
    â–ª Bluetooth  : â€¦
    â–ª Camera     : â€¦
    â–ª Controller : â€¦ (e.g. gamepads)
    â–ª Cooling    : â€¦
    â–ª Disc Tray  : â€¦
    â–ª Ethernet   : â€¦
    â–ª Geolocation: â€¦
    â–ª Haptic     : â€¦
    â–ª Keyboard   : â€¦
    â–ª Monitor    : â€¦
      â¬Ÿ Graphics: Vulkan â†’ Direct3D 12 â†’ Direct3D 11 â†’ Direct3D 10 â†’ Direct3D 9 â†’ Direct3D 8 â†’ OpenGL â†’ Metal â†’ Windows GDI â†’ X11 â†’ Quartz2D
    â–ª Mouse       : â€¦
    â–ª NFC         : â€¦
    â–ª Orientation : â€¦
    â–ª Performance : â€¦
    â–ª Processor(s): â€¦
    â–ª Speaker     : â€¦
    â–ª Storage     : â€¦
    â–ª Stylus      : â€¦
    â–ª Touchpad    : â€¦
    â–ª Touchpen    : â€¦
    â–ª Touchscreen : â€¦
    â–ª USB         : â€¦
    â–ª Wi-Fi       : â€¦
  â–´ Object
    â–ª Array
    â–ª Error â†’ Consider implementation support
    â–ª Function
    â–ª Integer â†’ Extended and multi-precision integer support; Features to treat integral objects as integers e.g. `Integer::add(NULL, class {}) == Integer::add(0, â€¦)`
    â–ª Memory
    â–ª Number â†’ Representations only â€” to differentiate from Mathematics API
    â–ª Reflection
    â–ª String â†’ Literals prefer source text encoding
      â¬Ÿ Regular Expression literals
      â¬Ÿ Rope
      â¬Ÿ Small string optimization
    â–ª â€¦ â†’ Non-literals; Consider Array-of-Structures vs Structure-of-Arrays implementation support
      â¬Ÿ Linked List
      â¬Ÿ Map
      â¬Ÿ Queue
      â¬Ÿ Set
      â¬Ÿ Stack
      â¬Ÿ Tuple
      â¬Ÿ Variant
  â–´ Process: â€¦
    â–ª Thread: â€¦
â€¢ UI: â€¦
  â–´ Desktop      : â€¦
  â–´ Notifications: â€¦
  â–´ Window       : â€¦
â€¢ Video: â€¦
  â•°â”€ MPEG-4 `.mp4`, â€¦
â€¢ Web
  â–´ CSS
  â–´ HTML
  â–´ JavaScript
  â–´ WASM
â€¢ Time
  â–´ Date: â€¦
  â–´ Greenwich Meridian

Constants
â€¢ Math::PHI â†’ Ï• â†’ Ï† â†’ `real` that denotes the most precise representation for the golden ratio (not just `(1 + âˆš5) Ã· 2`)
â€¢ Math::PI  â†’ Ï€     â†’ `real` that denotes the most precise representation for Pi               (the Archimedes' constant)
â€¢ Math::TAU â†’ Ï„     â†’ `real` that denotes the most precise representation for Tau              (not just `2Ï€`)
â€¢ NULL              â†’ `addr` null object for pointers
â€¢ Î“(â€¦)              â†’ Monoadic function which denotes the factorial of `â€¦`; See `https://en.wikipedia.org/wiki/Particular_values_of_the_gamma_function`
â€¢ Î (â€¦)              â†’ Variadic function which denotes all `â€¦` multiplied; Alternatives (e.g. `Ï€(â€¦)`) ignored
â€¢ Î£(â€¦)              â†’ Variadic function which denotes all `â€¦` summed;     Alternatives               ignored
â€¢ âˆ                 â†’ `real` that denotes the most minimal representation for Infinity
â€¢ â†‰                 â†’ `real` that denotes the most precise representation for zero-thirds
â€¢ Â½                 â†’ `real` that denotes the most precise representation for half
â€¢ â…“                 â†’ `real` that denotes the most precise representation for one-third
â€¢ Â¼                 â†’ `real` that denotes the most precise representation for one quarter
â€¢ â…•                 â†’ `real` that denotes the most precise representation for one-fifth
â€¢ â…™                 â†’ `real` that denotes the most precise representation for one-sixth
â€¢ â…                 â†’ `real` that denotes the most precise representation for one-seventh
â€¢ â…›                 â†’ `real` that denotes the most precise representation for one-eighth
â€¢ â…‘                 â†’ `real` that denotes the most precise representation for one-ninth
â€¢ â…’                 â†’ `real` that denotes the most precise representation for one-tenth
â€¢ â…”                 â†’ `real` that denotes the most precise representation for two-thirds
â€¢ â…–                 â†’ `real` that denotes the most precise representation for two-fifths
â€¢ Â¾                 â†’ `real` that denotes the most precise representation for three-quarter
â€¢ â…—                 â†’ `real` that denotes the most precise representation for three-fifths
â€¢ â…œ                 â†’ `real` that denotes the most precise representation for three-eighths
â€¢ â…˜                 â†’ `real` that denotes the most precise representation for four-fifths
â€¢ â…š                 â†’ `real` that denotes the most precise representation for five-sixths
â€¢ â…                 â†’ `real` that denotes the most precise representation for seven-eighths

Evaluators
â€¢ addrof     [(] â€¦ [)] â†’ Evaluates address of expression; Evaluates to `null` for `void` expressions or similar edge cases
â€¢ alignof    [(] â€¦ [)] â†’ Evaluates `byte` alignment of expression/ type
â€¢ assert     [(] â€¦ [)] â†’ Raises error if `(bool) â€¦` is falsy
â€¢ instanceof [(] T [)] â†’ Denotes object of type `T` in an unevaluated context
â€¢ nilof      [(] T [)] â†’ Represents extensible monoadic function(s) which denote the null object of type `T`
â€¢ sizeof     [(] â€¦ [)] â†’ Evaluates `byte` size of expression/ type
â€¢ typeof     [(] â€¦ [)] â†’ Deduces    type       of expression/ type

Features
â€¢ Binary, hexadecimal, and octal number literals support scientific notation e.g. `0x1.2p-3 == 1.125 * (2 ** -3)`
â€¢ Deferred line termination i.e. automatic semi-colon insertion
â€¢ Hash symbol (`#`) connotes special constructs or operations e.g. access specifiers, constructors, â€¦; Does not need its own entire line to be evaluated
â€¢ Keywords may be redefined as identifiers in certain contexts e.g. `function void function(auto function)`
â€¢ Multi-line comments support nested multi-line comments e.g. `non-comment /* comment /* comment */ */ non-comment`
â€¢ Properties or subobjects are padded strictly
â€¢ Niladic functions do not require parentheses to indicate parameters or structure
â€¢ Non-composite identifiers shall not include the hash symbol `#`
â€¢ REPL-agnostic support
â€¢ Single-line comments e.g. `non-comment // comment`
â€¢ Standard library uses `camelCase` and `PascalCase` formatting
â€¢ Source text encoding precedence: UTF-8 â†’ UTF-16 LE â†’ UTF-16 BE â†’ UTF-32 â†’ â€¦ â†’ ASCII

Keywords
â€¢ Class/ Function Attributes
  â–´ #noignore   â†’ Ensures return values are used
  â–´ #noinherits â†’ Prevents class inheritance
  â–´ #nooperator â†’ Prevents additional user-defined operator overloads on structure type i.e. `class` or `union`
  â–´ #noreturn   â†’ Prevents function return                                              i.e. `ret` assembly instruction
  â–´ #nothrow â€¦  â†’ Prevents exception handling                                           i.e. optimizes against stack unwound errors

â€¢ Source Directives
  â–´ #embed â€¦          â†’ See `#import` for value specification; Substitutes the external source as-is into the code
  â–´ #error â€¦          â†’ Compile-time error
  â–´ #export [{] â€¦ [}] â†’ Features must be explicitly exported for `#import`
  â–´ #import           â†’ Does not eagerly fail if specified value is invalid (fails on mismatched type)
    â–ª #import "file" â€¦ "path"   â†’ Determined by current working directory (absoluteness or relative-ness determined by filesystem, supports online URLs regardless)
    â–ª #import <standard-import> â†’ Determined by compiler/ interpreter install directory
    â–ª #import â€¦ else â€¦          â†’ Conditional import e.g. `#import â€¦ else #error â€¦`
  â–´ #warn â€¦ â†’ Compile-time warning

â€¢ Special Functions
  â–´ #constructor(â€¦)
  â–´ #get()
  â–´ #operator â€¦ e.g. `#operator +()`, `#operator +(â€¦)`, `#operator +(â€¦, â€¦)`, `#operator T()`, `#operator "ğŸ’™"(â€¦)`
  â–´ #set(â€¦)

â€¢ â€¦
  â–´ #private   [{] â€¦ [}]
  â–´ #protected [{] â€¦ [}]
  â–´ #public    [{] â€¦ [}]

  â–´ and
  â–´ not
  â–´ or
  â–´ xor

Operators
â€¢ â€¥                â†’ Refers to preceding top-level objects (excludes members) in the current expression e.g. `â€¥ .member == â€¥.member`
â€¢ â€¥1               â†’ Refers to first  top-level objects in the current expression e.g. `0 + â€¥1 == 0`
â€¢ â€¥2               â†’ Refers to second top-level objects in the current expression e.g. `0 +  1 == â€¥2`
â€¢ â€¥1 then â€¥2       â†’ Evaluation precedence i.e. Guarantees evaluation of `â€¥1` before `â€¥2`
â€¢ â€¥1 ? : â€¥2        â†’ `â€¥1 ? â€¥1 : â€¥2`
â€¢ â€¥1 ? â€¥2 :        â†’ `â€¥1 ? â€¥2 : â€¥1`
â€¢ â€¥n               â†’ Refers to last        top-level objects in the current expression e.g. `0 + â€¥n == 1`
â€¢ â€¥n1              â†’ Refers to penultimate top-level objects in the current expression e.g. `0 +  1 == â€¥n1`
â€¢ |â€¦|              â†’ Absolution e.g. `|-2 - 3| == 5`
â€¢ â€¦ â‰ª        â€¦     â†’ Bitwise left  shift
â€¢ â€¦ â‰ª=       â€¦     â†’ Bitwise left  shift compound assignment
â€¢ â€¦ â‰«        â€¦     â†’ Bitwise right shift
â€¢ â€¦ â‰«=       â€¦     â†’ Bitwise right shift compound assignment
â€¢ â€¦ &&=      â€¦     â†’ Boolean AND compound assignment
â€¢ â€¦ ||=      â€¦     â†’ Boolean OR  compound assignment
â€¢ â€¦ ^^       â€¦     â†’ Boolean XOR
â€¢ â€¦ ^^=      â€¦     â†’ Boolean XOR compound assignment
â€¢ â€¦ Ã·        â€¦     â†’ Division
â€¢ â€¦ =>   [{] â€¦ [}] â†’ Function â€” necessary for Lambdas; Ignore `â‡’` and `âŸ¹` tokens
â€¢ â€¦ â‰¥        â€¦     â†’ Greater Equals
â€¢ â€¦ â‰         â€¦     â†’ Inequality
â€¢ â€¦ â‰¤        â€¦     â†’ Lesser Equals
â€¢ â€¦ mod      â€¦     â†’ Modulus
â€¢ â€¦ Ã—        â€¦     â†’ Multiplication
â€¢ â€¦ rem      â€¦     â†’ Remainder
â€¢ â€¦ â‡”        â€¦     â†’ Signed comparison
â€¢ â€¦ <=>      â€¦     â†’ Signed comparison
â€¢ â€¦ inherits â€¦     â†’ Structured inheritance
â€¢ â€¦ âˆš        â€¦     â†’ â€¦th Root
â€¢ 0oâ€¦              â†’ Octal notation
â€¢ break    â€¦       â†’ Ends     `â€¦`-labelled block
â€¢ continue â€¦       â†’ Iterates `â€¦`-labelled block
â€¢ defer    â€¦       â†’ Ends current block and evaluates `â€¦`
â€¢ delete   â€¦       â†’ `destruct<typeof â€¦>(â€¦)`
â€¢ do while â€¦       â†’ Formatted consistently like `else if â€¦`
â€¢ if;              â†’ `if true`
â€¢ if not;          â†’ `if false`
â€¢ for;             â†’ `for true`
â€¢ for â€¦            â†’ `for ( ; â€¦; )`
â€¢ new T (â€¦)        â†’ `construct<T>(â€¦, alloc<Storage::HEAP>(sizeof T))`
â€¢ while;           â†’ `while true`
â€¢ @ â€¦              â†’ Derefences objects of type `addr`
â€¢ âˆš â€¦              â†’ Square Root
â€¢ âˆ› â€¦              â†’ Cubed  Root
â€¢ âˆœ â€¦              â†’ Fourth Root

Special Types
â€¢ #number â†’ Source representation of number literals e.g. converts formats like `-.1e-0` (to `-0.1`) to `{.length = 2u, .precision = 1u, .signed = true, .value = {0u, 1u}}`
  ```lapys
  class #number #noinherits #nooperator {
    usize   length
    usize   precision
    bool    signed
    uint4[] value
  }
  ```

Type Aliases
â€¢ alias bit     =              â€¦              â†’ Individually occupies minimum of one `byte`, but prefers packing multiple on the same (stack) frame            (`unsigned` only)
â€¢ alias bool    =              bit[â€¦]         â†’ Differs from `byte` due to similar pack preference to `bit`                                                    (`unsigned` only)
â€¢ alias byte    =              bit[â€¦]         â†’ Smallest                     unit        for hardware storage, automatically packs `CHAR_BIT` number of `bit`s (`unsigned` only)
â€¢ alias iaddr   =              signed   uaddr â†’ Signed `uaddr`               counterpart for signed   arithmetic
â€¢ alias int1    = alias i1   = signed   bit   â†’ Signed `uint1`   (or `u1`)   counterpart for signed   arithmetic
â€¢ alias int2    = alias i2   = long     i1    â†’ Signed `uint2`   (or `u2`)   counterpart for signed   arithmetic
â€¢ alias int4    = alias i4   = long     i2    â†’ Signed `uint4`   (or `u4`)   counterpart for signed   arithmetic
â€¢ alias int8    = alias i8   = long     i4    â†’ Signed `uint8`   (or `u8`)   counterpart for signed   arithmetic
â€¢ alias int16   = alias i16  = long     i8    â†’ Signed `uint16`  (or `u16`)  counterpart for signed   arithmetic
â€¢ alias int32   = alias i32  = long     i16   â†’ Signed `uint32`  (or `u32`)  counterpart for signed   arithmetic
â€¢ alias int64   = alias i64  = long     i32   â†’ Signed `uint64`  (or `u64`)  counterpart for signed   arithmetic
â€¢ alias int128  = alias i128 = long     i64   â†’ Signed `uint128` (or `u128`) counterpart for signed   arithmetic
â€¢ alias int256  = alias i256 = long     i128  â†’ Signed `uint256` (or `u256`) counterpart for signed   arithmetic
â€¢ alias intmax  = alias imax = signed   â€¦     â†’ Signed `uintmax` (or `umax`) counterpart for signed   arithmetic
â€¢ alias intmin  = alias imin = signed   â€¦     â†’ Signed `uintmin` (or `umin`) counterpart for signed   arithmetic
â€¢ alias int     =              signed   uint  â†’ Signed `uint`                counterpart for signed   arithmetic
â€¢ alias isize   =              signed   usize â†’ Signed `usize`               counterpart for signed   arithmetic
â€¢ alias uint1   = alias u1   = unsigned bit   â†’ 1-bit                        unit        for unsigned arithmetic
â€¢ alias uint2   = alias u2   = long     u1    â†’ 2-bit                        unit        for unsigned arithmetic
â€¢ alias uint4   = alias u4   = long     u2    â†’ 4-bit                        unit        for unsigned arithmetic
â€¢ alias uint8   = alias u8   = long     u4    â†’ 8-bit                        octet       for unsigned arithmetic (and parity with most modern processors)
â€¢ alias uint16  = alias u16  = long     u8    â†’ 16-bit                       unit        for unsigned arithmetic
â€¢ alias uint32  = alias u32  = long     u16   â†’ 32-bit                       unit        for unsigned arithmetic
â€¢ alias uint64  = alias u64  = long     u32   â†’ 64-bit                       unit        for unsigned arithmetic
â€¢ alias uint128 = alias u128 = long     u64   â†’ 128-bit                      unit        for unsigned arithmetic
â€¢ alias uint256 = alias u256 = long     u128  â†’ 256-bit                      unit        for unsigned arithmetic
â€¢ alias uaddr   =              bit[â€¦]         â†’ Largest                      unit        for pointer representations
â€¢ alias uint    =              bit[â€¦]         â†’ Default                      unit        for hardware instructions
â€¢ alias uintmax = alias umax = bit[â€¦]         â†’ Largest                      unit        for hardware instructions; Extending `uintmax` via the `long` qualification can be allowed through software emulation
â€¢ alias uintmin = alias umin = byte           â†’ Smallest                     unit        for hardware instructions; `bit` and `bool` are the smallest `unsigned` types however
â€¢ alias usize   =              bit[â€¦]         â†’ Largest                      unit        for array bounds and size representations

Type Qualifications â†’ Types are strictly to the left-hand side of property/ variable declarations
â€¢ First-level â†’ Only applicable once on types
  â–´ long     T â†’ Denotes an extended arithmetic type; Can not be used in conjunction with `short` qualification â€” `typeof(long  uint128) == typeof(uint128)`
  â–´ short    T â†’ Denotes a       sub-arithmetic type; Can not be used in conjunction with `long`  qualification â€” `typeof(short uint1)   == typeof(uint1)`
  â–´ signed   T â†’ Denotes an integer type as signed
  â–´ unsigned T â†’ Denotes an integer type as non-signed

â€¢ Second-level â†’ Only applicable once on types and third-level qualifications
  â–´ const      T â†’ Parameters and variables are storage-constant by default
  â–´ function   T â†’ Denotes a function
  â–´ generic<â€¦> T â†’ Denotes a (generic) template
  â–´ mutable    T â†’ Parameters and variables can only instantiate modifiable memory through this qualification; Attempts to modify a `const`-instantiated object by spoofing `mutable` results in an error

â€¢ Third-level
  â–´ auto â†’ Automatically deduce the type of an instantiation or return expression

  â–´ T addr â†’ Interprets the object as a pointer to memory of type `T`
    â–ª `addr`      automatically deduces the type of its applied expression;                   `auto addr` is invalid syntax
    â–ª `void addr` denotes untyped pointers and shall not be traversed like byte pointers e.g. `byte addr`

  â–´ T ref â†’ Interprets the object as an alias some other promised object of type `T`
    â–ª `ref`      may be second-level qualified (i.e. `T â€¦ ref`) regardless of the meaninglessness
    â–ª `ref`      automatically deduces the type of its applied expression;     `auto ref` is invalid syntax
    â–ª `void ref` denotes untyped references and has extremely limited use e.g. `sizeof((void ref) â€¦) == 0`
    â–ª References can not be re-aliased to other promised objects

  â–´ T[] â†’ Interprets the object as an unbounded array of objects of type `T`
    â–ª `T[]` may be second-level qualified (i.e. `T â€¦[]`) regardless of the meaninglessness

  â–´ T[â€¦] â†’ Interprets the object as an bounded array of â€¦ objects of type `T`
    â–ª `T[â€¦]` may be second-level qualified (i.e. `T â€¦[â€¦]`) regardless of the meaninglessness

Type Specifications
â€¢ alias â€¦ â†’ Alias      type
â€¢ class â€¦ â†’ Composite  type with methods and a namespace
â€¢ enum  â€¦ â†’ Enumerable type with constant enumerators
â€¢ union â€¦ â†’ Selective  type with methods and a namespace (and only one active property if available)

â€¢ static   T â†’ Denotes static-allocated storage for variables
â€¢ threaded T â†’ Denotes thread-local     storage for variables

â€¦
```lapys
  class A    { class B {} }   // No `struct` keyword, but classes and unions are structure types
  class A::B {  }             /* Identifiers can composite scope operators `::` with other identifiers
                                   â€” `class A::B` runs into a naming conflict with `class B` defined within `class A` */
  generic<â€¦> class A<â€¦>::B {} // Assumes some `class A` is `generic` and declares `class A<â€¦>::B`

  // Generics may be qualified onto `alias`, `class`, `function`, and `union` declarations only
  generic<usize width> class uintwidth #noinherits #nooperator {
    #private
      bit[width] value // Zero-sized subobjects do not contribute to the size of their object e.g. `bit[0]`

    #public
      #constructor(#number = 0u) { â€¦ } // `function` qualification is optional for `#constructor` and `#operator`

      uintwidth<width * 2u>                                #operator long   { â€¦ }
      uintwidth<width / 2u ? width / 2u : width ? 1u : 0u> #operator short  { â€¦ }
      intwidth <width>                                     #operator signed { â€¦ }

    /* â€¦ */
  }

  generic <usize width>
  class intwidth #noinherits #nooperator {
    // `class` and `union` types are `#public` access by default
    bit                              sign
    uintwidth<width - (0u != width)> value

    uintwidth<width> #operator unsigned { â€¦ }
    /* â€¦ */
  }

  /* Additional base types (and aliases) */
  generic <type base, usize capacity>
  class array<base, capacity> #nooperator {
    #public
      usize length {
        #get => default
        #set(usize value, mutable array addr object) { if (@object.resize(value)) @this = value }
      }

    #private
      union {
        base[capacity] automatic
        base addr      dynamic
      }

    /* â€¦ */
    #public
      #constructor(base...) { â€¦ }

      function usize push  (base...) { â€¦ }
      function bool  resize(usize)   { â€¦ }

      explicit #operator base addr      { â€¦ }
      #operator          base[capacity] { â€¦ }
  }

  generic <usize significance, usize place>
  class floatwidth #noinherits #nooperator {
    static usize place        = place
    static usize significance = significance

    #private
      bit               sign
      bit[significance] exponent
      bit[place]        mantissa

    #public
      #constructor(#number = 0.0f) { â€¦ }
      #operator uintwidth<place + significance + 1u> { â€¦ }

      /* â€¦ */
  }

  generic <type base>
  class iterator {
    function base addr begin { â€¦ }
    function base addr end   { â€¦ }
  }

  generic <type base>
  class span #nooperator {
    #public  usize     length
    #private base addr value

    /* â€¦ */
    #public
      #operator base addr { â€¦ }
  }

  class enum string::encoding inherits uintwidth<10zu> #nooperator {
    â€¦,
    US_ASCII, ANSI_X3_4_1968 = US_ASCII, ANSI_X3_4_1986 = US_ASCII, cp367 = US_ASCII, csASCII = US_ASCII, IBM367 = US_ASCII, iso_ir_6 = US_ASCII, ISO646_US = US_ASCII, ISO_646_irv_1991 = US_ASCII, us = US_ASCII,
    us_dk,    csUSDK    = us_dk,
    UTF_16,   csUTF16   = UTF_16,
    UTF_16BE, csUTF16BE = UTF_16BE,
    UTF_16LE, csUTF16LE = UTF_16LE,
    UTF_32,   csUTF32   = UTF_32,
    UTF_32BE, csUTF32BE = UTF_32BE,
    UTF_32LE, csUTF32LE = UTF_32LE,
    UTF_7,    csUTF7    = UTF_7,
    UTF_8,    csUTF8    = UTF_8,
    â€¦
  }

  generic <usize capacity = 0u, string::encoding encoding = string::encoding::UTF_8> // Encoded UTF-8 by default but defers to the source text encoding
  class string #nooperator {
    static string::encoding encoding = encoding

    #private
      // Consider ropes --- CITE (Lapys) -> https://en.wikipedia.org/wiki/Rope_(data_structure)
      array<char, capacity> value

    #public
      #constructor(char[])  { â€¦ }
      #constructor(char...) { â€¦ }

      explicit #operator char addr             { â€¦ }
      #operator          char       [capacity] { â€¦ }
      #operator          array<char, capacity> { â€¦ }
  }

  class bigfloat #noinherits #nooperator
  class bigint   #noinherits #nooperator
  class biguint  #noinherits #nooperator
  class real     #noinherits #nooperator

  alias bfloat16 = alias bf16 = â€¦
  alias char8    =              uint8
  alias char16   =              uint16
  alias char32   =              uint32
  alias float    =              â€¦
  alias float8   = alias f8   = floatwidth<4zu,  3zu>   // CITE (Lapys) -> https://en.wikipedia.org/wiki/Minifloat
  alias float16  = alias f16  = floatwidth<5zu,  10zu>  // CITE (Lapys) -> https://en.wikipedia.org/wiki/Half-precision_floating-point_format
  alias float32  = alias f32  = floatwidth<8zu,  23zu>  // CITE (Lapys) -> https://en.wikipedia.org/wiki/Single-precision_floating-point_format
  alias float64  = alias f64  = floatwidth<11zu, 52zu>  // CITE (Lapys) -> https://en.wikipedia.org/wiki/Double-precision_floating-point_format
  alias float80  = alias f80  = floatwidth<15zu, 64zu>  // CITE (Lapys) -> https://en.wikipedia.org/wiki/Extended_precision
  alias float128 = alias f128 = floatwidth<15zu, 112zu> // CITE (Lapys) -> https://en.wikipedia.org/wiki/Quadruple-precision_floating-point_format
  alias float256 = alias f256 = floatwidth<19zu, 236zu> // CITE (Lapys) -> https://en.wikipedia.org/wiki/Octuple-precision_floating-point_format

  /* â€¦ */
  function auto double(auto n) { return n Ã— 2 }
  function auto double(auto n) =>       n Ã— 2
  (auto n)                     =>       n Ã— 2
  (n)                          =>       n Ã— 2
  n                            =>       n Ã— 2
  $1 Ã— 2

  namespace Storage {
    enum Type inherits uintmin #nooperator {
      AUTO,
      DYNAMIC,
      GLOBAL
    }

    generic<Storage::Type = Storage::AUTO> function span<byte>                                        alloc    (usize)                               { â€¦ }
    generic<type>                          function type addr                                         construct(auto...,           type addr = NULL) { â€¦ }
    generic<type>                          function typeof(instanceof type.#destructor(arguments...)) destruct (auto... arguments, type addr = NULL) { â€¦ }
  }

  using object {
    .property // object.property
  }
```
